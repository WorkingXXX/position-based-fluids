layout (local_size_x = LOCAL_SIZE) in;

layout (binding = 0, rgba32f) uniform           imageBuffer  imgPredicted;
layout (binding = 1, r32f)    uniform writeonly imageBuffer  imgDensity;
layout (binding = 2, r32i)    uniform readonly  iimageBuffer imgFriendsList;

layout (binding = 0) uniform samplerBuffer  txtPredicted;

layout (location = 0) uniform int N;

void main()                               
{
    // Scaling = lambda
    const int i = int(gl_GlobalInvocationID.x);
    if (i >= N) return;

    vec4 predicted = texelFetch(txtPredicted, i);
    const float e = Params.epsilon * Params.restDensity;

    // Sum of rho_i, |nabla p_k C_i|^2 and nabla p_k C_i for k = i
    float density_sum = 0.0f;
    float gradient_sum_k = 0.0f;
    vec3 gradient_sum_k_i = vec3(0.0f);

    // read number of friends
    int totalFriends = 0;
    int circleParticles[MAX_FRIENDS_CIRCLES];
    for (int j = 0; j < MAX_FRIENDS_CIRCLES; j++) 
        totalFriends += circleParticles[j] = imageLoad(imgFriendsList, j * MAX_PARTICLES_COUNT + i).x;

    int proccedFriends = 0;
    for (int iCircle = 0; iCircle < MAX_FRIENDS_CIRCLES; iCircle++)
    {
        // Check if we want to process/skip next friends circle
        if (float(proccedFriends) / totalFriends <= 0.5f)
        {
            // Add next circle to process count
            proccedFriends += circleParticles[iCircle];

            // Compute friends start offset
            int baseIndex = FRIENDS_BLOCK_SIZE +                                      // Skip friendsCount block
                            iCircle * (MAX_PARTICLES_COUNT * MAX_FRIENDS_IN_CIRCLE) + // Offset to relevent circle
                            i;                                                        // Offset to particle_index                              

            int numFriendsInCircle = circleParticles[iCircle];
            // Process friends in circle
            for (int iFriend = 0; iFriend < numFriendsInCircle; iFriend++)
            {
                // Read friend index from friends_list
                const int j_index = imageLoad(imgFriendsList, baseIndex + iFriend * MAX_PARTICLES_COUNT).x;

                // Get j particle data
                vec4 j_data = texelFetch(txtPredicted, j_index);

                vec3 r = predicted.xyz - j_data.xyz;
                const float r_length_2 = dot(r,r);

                // Required for numerical stability
                if (r_length_2 < Params.h_2)
                {
                    const float r_length = sqrt(r_length_2);

                    // CAUTION: the two spiky kernels are only the same
                    // because the result is only used sqaured
                    // equation (8), if k = i
                    const float h_r_diff = Params.h - r_length;
                    const vec3 gradient_spiky = GRAD_SPIKY_FACTOR * h_r_diff * h_r_diff *
                                                  r / r_length;

                    // equation (2)
                    const float h2_r2_diff = Params.h_2 - r_length_2;
                    density_sum += h2_r2_diff * h2_r2_diff * h2_r2_diff;

                    // equation (9), denominator, if k = j
                    gradient_sum_k += dot(gradient_spiky, gradient_spiky);

                    // equation (8), if k = i
                    gradient_sum_k_i += gradient_spiky;
                }
            }
        }
    }

    // Apply Poly6 factor to density and save density
    density_sum *= POLY6_FACTOR;
    imageStore(imgDensity, i, vec4(density_sum,0,0,0));

    // equation (9), denominator, if k = i
    gradient_sum_k += dot(gradient_sum_k_i, gradient_sum_k_i);

    // equation (1)
    float density_constraint = (density_sum / Params.restDensity) - 1.0f;

    // equation (11)
    float scalingResult = -1.0f * density_constraint /
                          (gradient_sum_k / (Params.restDensity * Params.restDensity) + e);

    imageStore(imgPredicted, i, vec4(predicted.xyz,scalingResult));
}
