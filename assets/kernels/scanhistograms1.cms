// local size = (_RADIX * _GROUPS * _ITEMS / 2) / _HISTOSPLIT
// unfortunately no brackets are allowed here... so we have to calculate it manually...
layout (local_size_x = 64) in;

layout (binding = 0, r32ui) uniform uimageBuffer imgHistogram;
layout (binding = 1, r32ui) uniform uimageBuffer imgGlobSum;

shared uint temp[_MEMCACHE];

void main()                               
{
    uint it = gl_LocalInvocationID.x;
    uint ig = gl_GlobalInvocationID.x;
    uint decale = 1;
    uint slots = gl_WorkGroupSize.x * 2 ;
    uint gr = gl_WorkGroupID.x;

    // load input into local memory
    // up sweep phase
    temp[2 * it] = imageLoad(imgHistogram, int(2 * ig)).x;
    temp[2 * it + 1] = imageLoad(imgHistogram, int(2 * ig + 1)).x;

    memoryBarrierShared();  

    // parallel prefix sum (algorithm of Blelloch 1990)
    for (uint d = slots >> 1; d > 0; d >>= 1)
    {
        memoryBarrierShared( );
        if (it < d)
        {
            uint ai = decale * (2 * it + 1) - 1;
            uint bi = decale * (2 * it + 2) - 1;
            temp[bi] += temp[ai];
        }
        decale *= 2;
    }

    // store the last element in the global sum vector
    // (maybe used in the next step for constructing the global scan)
    // clear the last element
    if (it == 0)
    {
        imageStore(imgGlobSum, int(gr), ivec4(temp[slots - 1],0,0,0));
        temp[slots - 1] = 0;
    }
    memoryBarrierShared( );

    // down sweep phase
    for (uint d = 1; d < slots; d *= 2)
    {
        decale >>= 1;
        memoryBarrierShared( );

        if (it < d)
        {
            uint ai = decale * (2 * it + 1) - 1;
            uint bi = decale * (2 * it + 2) - 1;

            uint t = temp[ai];
            temp[ai] = temp[bi];
            temp[bi] += t;
        }

    }
    memoryBarrierShared( );

    // write results to device memory
    imageStore(imgHistogram, int(2 * ig), ivec4(temp[2 * it],0,0,0));
    imageStore(imgHistogram, int(2 * ig + 1), ivec4(temp[2 * it + 1],0,0,0));
}
