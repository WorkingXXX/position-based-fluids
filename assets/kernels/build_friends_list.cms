layout (local_size_x = LOCAL_SIZE) in;

layout (binding = 0, rgba32f) uniform readonly  imageBuffer  imgPredicted;
layout (binding = 1, r32i)    uniform readonly  iimageBuffer imgCells;
layout (binding = 2, r32i)    uniform writeonly iimageBuffer imgFriendsList;

layout (location = 0) uniform int N;

void main()
{
    const int i = int(gl_GlobalInvocationID.x);
    if (i >= N) return;
    
    const float MIN_R = 0.3f * Params.h;

    // Define circle particle counter varible
    int circleParticles[MAX_FRIENDS_CIRCLES];
    for (int j = 0; j < MAX_FRIENDS_CIRCLES; j++)
        circleParticles[j] = 0;

    // Start grid scan
    vec4 predicted = imageLoad(imgPredicted, i);
    ivec3 currentCell = ivec3(predicted.xyz / Params.h);

    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                int cell_index = calcGridHash(currentCell + ivec3(x, y, z));

                // find first and last particle in this cell
                ivec2 cell_boundary = ivec2(imageLoad(imgCells,cell_index*2+0).x, imageLoad(imgCells,cell_index*2+1).x);
                
                // skip empty cells
                if(cell_boundary.x == END_OF_CELL_LIST) continue;
                    
                // iterate over all particles in this cell
                for(int j_index = cell_boundary.x; j_index <= cell_boundary.y; ++j_index) 
                {
                    // Skip self
                    if (i != j_index)
                    {
                        // Get j particle position
                        vec4 predicted_j = imageLoad(imgPredicted, j_index);
                        
                        // Ignore unfriendly particles (r > h)
                        const vec3 r = predicted.xyz - predicted_j.xyz;
                        const float r_length_2 = dot(r, r);
                        if (r_length_2 >= Params.h_2)
                            continue;

                        // Find particle circle
                        const float adjusted_r = max(0.0f, (sqrt(r_length_2) - MIN_R) / (Params.h - MIN_R));
                        const int j_circle = min(int(adjusted_r * adjusted_r * adjusted_r * MAX_FRIENDS_CIRCLES), MAX_FRIENDS_CIRCLES - 1);

                        // Make sure particle doesn't have too many friends
                        if (circleParticles[j_circle] >= MAX_FRIENDS_IN_CIRCLE)
                        {
                            // printf("Damn! we need a bigger MAX_FRIENDS_IN_CIRCLE\n");
                            continue;
                        }

                        // Increments friends in circle counter
                        int friendIndex = circleParticles[j_circle]++;

                        // Add friend to relevent circle
                        int index = FRIENDS_BLOCK_SIZE +                                          // Skip friendsCount block
                                    j_circle    * (MAX_PARTICLES_COUNT * MAX_FRIENDS_IN_CIRCLE) + // Offset to relevent circle
                                    friendIndex * (MAX_PARTICLES_COUNT) +                         // Offset to relevent friend_index
                                    i;                                                            // Offset to particle_index                    
                        
                        imageStore(imgFriendsList, index, ivec4(j_index,0,0,0));
                    }
                }
            }
        }
    }

    // Save counters
    for (int iCircle = 0; iCircle < MAX_FRIENDS_CIRCLES; iCircle++)
    {
        imageStore(imgFriendsList, iCircle * MAX_PARTICLES_COUNT + i, ivec4(circleParticles[iCircle],0,0,0));
    }    
}
